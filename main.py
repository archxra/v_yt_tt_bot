import os
import re
import logging
import subprocess
import asyncio
import threading
import time
from collections import deque
from typing import Optional
from flask import Flask, request
from telegram import Update, Message
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
)
import yt_dlp

# Global variables with thread-safe access
app_loop = None
app_loop_lock = threading.Lock()
application = None

processed_updates = deque(maxlen=1000)

print("Cookies file exists:", os.path.exists("cookies.txt"))

# Setup logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

TELEGRAM_TOKEN = '7748710830:AAFY98we_u6AQf8QiyfyAwhsfX8Hw8iK7kA'  # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à —Ç–æ–∫–µ–Ω

# ------------------ Flask App ------------------

app = Flask(__name__)

@app.route('/')
def home():
    return "I'm alive!"

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π event loop –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
app_loop = None

@app.route('/webhook', methods=['POST'])
def webhook_handler():
    try:
        json_data = request.get_json(force=True)
        logger.debug(f"Raw update: {json_data}")

        with app_loop_lock:
            loop = app_loop
        
        if not loop or not application:
            logger.critical("Event loop or application not initialized")
            return "Service Unavailable", 503

        update = Update.de_json(json_data, application.bot)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
        if update.update_id in processed_updates:
            logger.info(f"Ignoring duplicate update: {update.update_id}")
            return "OK", 200
        processed_updates.append(update.update_id)
        
        # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
        msg_type = 'no_message'
        if update.effective_message:
            if hasattr(update.effective_message, 'content_type'):
                msg_type = update.effective_message.content_type
            else:
                msg_type = 'special_message'
        
        logger.info(f"Processing update: {update.update_id} [type: {msg_type}]")
        
        future = asyncio.run_coroutine_threadsafe(
            application.process_update(update),
            loop
        )
        
        try:
            future.result(timeout=30)  # –£–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π —Ç–∞–π–º–∞—É—Ç
        except TimeoutError:
            logger.error("üïí –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è (30 —Å–µ–∫)")
            return "Timeout", 500

    except Exception as e:
        logger.error(f"Fatal webhook error: {str(e)}", exc_info=True)
        return "Internal Server Error", 500
    
    return "OK", 200

def run_flask():
    port = int(os.environ.get("PORT", 8080))
    app.run(host="0.0.0.0", port=port)

# ------------------ Utility Functions ------------------

def extract_url(text: str) -> str:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç –ø–µ—Ä–≤—É—é http(s) —Å—Å—ã–ª–∫—É –∏–∑ —Ç–µ–∫—Å—Ç–∞ –∏ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –æ–Ω–∞ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–º –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞–º.
    """
    match = re.search(r'(https?://\S+)', text)
    if match:
        url = match.group(1)
        if any(domain in url.lower() for domain in ["youtube.com", "youtu.be", "tiktok.com", "pin.it", "pinterest.com"]):
            return url
    return None

def parse_title(full_title: str) -> tuple:
    # –£–ª—É—á—à–µ–Ω–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–µ–π
    patterns = [
        r'(.*?)\s*[-‚Äì‚Äî:]\s*(.*)',  # –û—Å–Ω–æ–≤–Ω–æ–π –ø–∞—Ç—Ç–µ—Ä–Ω
        r'(.*?)\s*[\"‚Äú](.*?)[\"‚Äù]',  # –ù–∞–∑–≤–∞–Ω–∏–µ –≤ –∫–∞–≤—ã—á–∫–∞—Ö
        r'(.*?)\s*\((.*?)\)'  # –ù–∞–∑–≤–∞–Ω–∏–µ –≤ —Å–∫–æ–±–∫–∞—Ö
    ]
    
    for pattern in patterns:
        match = re.match(pattern, full_title)
        if match:
            return match.group(1).strip(), match.group(2).strip()
    
    return None, full_title

# ------------------ Download Functions ------------------

def download_video(url: str) -> str:
    ydl_opts = {
        'outtmpl': '%(id)s.%(ext)s',
        'noplaylist': True,
        'quiet': True,
        'cookiefile': 'cookies.txt',
    }
    # –ï—Å–ª–∏ —Å—Å—ã–ª–∫–∞ —Å Pinterest, —Å–∫–∞—á–∏–≤–∞–µ–º –≤–∏–¥–µ–æ+–∞—É–¥–∏–æ –∏ –æ–±—ä–µ–¥–∏–Ω—è–µ–º –∏—Ö
    if 'pin.it' in url.lower():
        ydl_opts['format'] = 'bestvideo+bestaudio/best'
        ydl_opts['merge_output_format'] = 'mp4'
    else:
        ydl_opts['format'] = 'mp4'
    
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info_dict = ydl.extract_info(url, download=True)
        filename = ydl.prepare_filename(info_dict)
        if not filename.endswith('.mp4'):
            base, _ = os.path.splitext(filename)
            new_filename = base + '.mp4'
            os.rename(filename, new_filename)
            filename = new_filename
    return filename

def download_audio(url: str) -> str:
    ydl_opts = {
        'format': 'bestaudio/best',
        'outtmpl': 'temp/%(id)s.%(ext)s',
        'noplaylist': True,
        'cookiefile': 'cookies.txt',
        'external_downloader': 'aria2c',
        'external_downloader_args': ['-x16', '-s16', '-k5M'],
        'socket_timeout': 30,
        'noprogress': True,
        'writethumbnail': True,
        'postprocessors': [{
            'key': 'FFmpegExtractAudio',
            'preferredcodec': 'mp3',
            'preferredquality': '192',
        }],
    }
    
    thumbnail = None  # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
    base = None  # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
    thumbnail = None
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info_dict = ydl.extract_info(url, download=True)
            filename = os.path.abspath(ydl.prepare_filename(info_dict))
            
            time.sleep(2)  # 2 —Å–µ–∫—É–Ω–¥—ã –∑–∞–¥–µ—Ä–∂–∫–∏
            if not os.path.exists(filename):
                raise FileNotFoundError(f"Downloaded file {filename} not found")
            
            base, _ = os.path.splitext(filename)  # –¢–µ–ø–µ—Ä—å base –≤—Å–µ–≥–¥–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±–ª–æ–∂–∫–∏
            thumbnail_path = base + ".webp"
            if os.path.exists(thumbnail_path):
                os.rename(thumbnail_path, base + ".jpg")
                thumbnail = base + ".jpg"
            
            # –ü–∞—Ä—Å–∏–Ω–≥ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
            full_title = info_dict.get('title', 'Unknown Title')
            artist, song_title = parse_title(full_title)
            if not artist:
                artist = info_dict.get('uploader', 'Unknown Artist')
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è
            mp3_filename = base + ".mp3"
            cmd = [
                'ffmpeg', '-y',
                '-i', filename,
                '-metadata', f'title={song_title}',
                '-metadata', f'artist={artist}',
                '-c:a', 'copy',
                '-id3v2_version', '3',
                '-loglevel', 'error',
                mp3_filename
            ]
            
            if thumbnail:
                cmd += [
                    '-i', thumbnail,
                    '-c:v', 'copy',
                    '-map', '0:a',
                    '-map', '1:v',
                    '-metadata:s:v', 'title="Album cover"',
                    '-metadata:s:v', 'comment="Cover (front)"'
                ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode != 0:
                logger.error(f"FFmpeg error: {result.stderr}")
                raise RuntimeError(f"Audio conversion failed: {result.stderr}")
            
            return mp3_filename
            
    finally:
        temp_files = []
        if filename:
            temp_files.append(filename)
        if base:  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ base
            temp_files.extend([
                base + ".webp",
                base + ".webm",
                base + ".jpg",
                base + ".mp3"
            ])
        if thumbnail:
            temp_files.append(thumbnail)
        for f in temp_files:
            if f and os.path.exists(f):
                try:
                    os.remove(f)
                except Exception as e:
                    logger.warning(f"Failed to delete {f}: {str(e)}")

# ------------------ Telegram Bot Handlers ------------------

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(
        "Hallo! Senden Sie mir einen Videolink f√ºr MP4 oder verwenden Sie den Befehl /mp3 <link>, um Audio (MP3) zu erhalten.\n"
        "Unterst√ºtzte Links: YouTube, TikTok und Pinterest."
    )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
    if not update.message or not update.message.text:
        logger.warning("Empty message received: %s", update)
        return

    text = update.message.text
    url = extract_url(text)
    
    if not url:
        if update.message.chat.type == "private":
            await update.message.reply_text("Bitte senden Sie einen g√ºltigen Link (YouTube, TikTok, Pinterest).")
        return
        
    try:
        progress_msg = await update.message.reply_text("Ich lade das Video herunter, warte eine Weile...")
        filename = download_video(url)
        
        with open(filename, 'rb') as video:
            await update.message.reply_video(video=video)
            
        os.remove(filename)
        
    except yt_dlp.DownloadError as e:
        logger.error(f"Download error: {str(e)}")
        await update.message.reply_text("‚ö†Ô∏è Video konnte nicht heruntergeladen werden. M√∂gliche Ursachen:\n"
                                      "- Altersbeschr√§nkung\n"
                                      "- Geoblocking\n"
                                      "- Ung√ºltiger Link")
    except Exception as e:
        logger.exception("Critical error in video download")
        await update.message.reply_text("‚ùå Schwerer Fehler bei der Verarbeitung")
        
    finally:
        if progress_msg:
            await progress_msg.delete()

async def mp3_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    progress_msg = None
    try:
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è
        if not update.message or not update.message.text:
            logger.error("–ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /mp3 –±–µ–∑ —Å–æ–æ–±—â–µ–Ω–∏—è")
            return

        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ URL
        url = None
        if context.args:
            # –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è URL —Å –ø—Ä–æ–±–µ–ª–∞–º–∏
            potential_url = " ".join(context.args)
            if extract_url(potential_url):
                url = potential_url
        else:
            url = extract_url(update.message.text)

        # –í—Ç–æ—Ä–∏—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ –ø—Ä—è–º–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ
        if not url:
            url = extract_url(update.message.text)

        # –í–∞–ª–∏–¥–∞—Ü–∏—è URL
        if not url or not url.startswith(("http://", "https://")):
            logger.warning(f"Ung√ºltige URL: {url}")
            await update.message.reply_text("‚ùå Ung√ºltiger Link. Beispiel f√ºr das richtige Format:\n/mp3 https://youtu.be/...")
            return

        # –ù–∞—á–∞–ª–æ –∑–∞–≥—Ä—É–∑–∫–∏
        progress_msg = await update.message.reply_text("‚è≥ Ich beginne mit der Audioverarbeitung...")
        
        # –ó–∞–≥—Ä—É–∑–∫–∞ –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è
        filename = download_audio(url)
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
        base = os.path.splitext(filename)[0]
        song_title = os.path.basename(base)
        artist = "Unknown Artist"
        
        # –û—Ç–ø—Ä–∞–≤–∫–∞ –∞—É–¥–∏–æ
        with open(filename, 'rb') as audio_file:
            thumb_path = base + ".jpg"
            thumb = open(thumb_path, 'rb') if os.path.exists(thumb_path) else None
            
            await update.message.reply_audio(
                audio=audio_file,
                title=song_title,
                performer=artist,
                thumb=thumb,
                read_timeout=30,
                write_timeout=30
            )
            
        if thumb:
            thumb.close()
        
        # –§–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è
        os.remove(filename)
        await progress_msg.delete()

    except yt_dlp.DownloadError as e:
        error_msg = f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {str(e)}"
        logger.error(error_msg)
        await handle_error(update, progress_msg, "üö´ Fehler beim Herunterladen des Videos. √úberpr√ºfen Sie:\n- Verf√ºgbarkeit des Videos\n- Altersbeschr√§nkungen\n- Korrektheit des Links")
    
    except subprocess.CalledProcessError as e:
        logger.error(f"FFmpeg error: {e.stderr.decode()}")
        await handle_error(update, progress_msg, "‚ö†Ô∏è Audio-Konvertierung ist fehlgeschlagen. Versuchen Sie es sp√§ter")
    
    except Exception as e:
        logger.error(f"Critical MP3 error: {str(e)}", exc_info=True)
        await handle_error(update, progress_msg, "‚ÄºÔ∏è Interner Serverfehler")

    except telegram.error.TimedOut:
        await update.message.reply_text("‚åõ Das Timeout ist abgelaufen, versuchen Sie es sp√§ter")

async def handle_error(update: Update, progress_msg: Optional[Message], text: str):
    """–£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫"""
    try:
        if progress_msg:
            await progress_msg.delete()
        if update and update.message:
            await update.message.reply_text(text)
    except Exception as e:
        logger.error(f"Error handling failed: {str(e)}", exc_info=True)

async def ping_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not update.message or not update.message.text:
        return
    if update.message.text.strip().lower() == "–ø–∏–Ω–≥":
        await update.message.reply_text("Der Bot funktioniert erfolgreich!!")

# ------------------ Main Function ------------------

def run_event_loop():
    global app_loop, application
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    with app_loop_lock:
        app_loop = loop

    application = Application.builder().token(TELEGRAM_TOKEN).pool_timeout(30).build()
    
    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –∫–æ–º–∞–Ω–¥
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("mp3", mp3_command))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_handler(
        MessageHandler(
            filters.TEXT 
            & (filters.ChatType.GROUP | filters.ChatType.SUPERGROUP)
            & filters.Regex(r'^(?i:–ø–∏–Ω–≥)$'),
            ping_handler
        )
    )

    WEBHOOK_URL = os.environ.get("WEBHOOK_URL", "https://v-yt-tt-bot.onrender.com/webhook")
    loop.run_until_complete(application.initialize())
    loop.run_until_complete(application.bot.set_webhook(WEBHOOK_URL))
    
    loop.run_forever()

def main() -> None:
    event_loop_thread = threading.Thread(target=run_event_loop, daemon=True)
    event_loop_thread.start()
    time.sleep(2)
    run_flask()

if __name__ == '__main__':
    main()
